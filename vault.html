<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- iOS Safari -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <!-- Chrome, Firefox OS and Opera Status Bar Color -->
  <meta name="theme-color" content="#FFFFFF">
  <meta property="og:title" content="Vault - IJCTF 2021">
  
  <meta name="description" content="A forensics category challenge on recovering TLS session keys from a packet capture, and decrypting TLS traffic tunnelled over ICMP (ping) through a SOCKS proxy, then recovering files from partial HTTP/2 requests.">
  <meta property="og:description" content="A forensics category challenge on recovering TLS session keys from a packet capture, and decrypting TLS traffic tunnelled over ICMP (ping) through a SOCKS proxy, then recovering files from partial HTTP/2 requests.">
  
  <meta property="og:type" content="blog">
  <title>Vault - IJCTF 2021</title>
  <!-- Favicon -->
  
  <link rel="shortcut icon" href="https://samillwong.github.io/images/profile.jpg">
  
  <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
  <link rel="stylesheet" type="text/css"
    href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.19.0/themes/prism.min.css">
  <link rel="stylesheet" type="text/css" href="css/SourceSansPro.css">
  <link rel="stylesheet" type="text/css" href="css/notablog.css">
  <link rel="stylesheet" type="text/css" href="css/theme.css">
  <style>
    :root {
      font-size: 18px;
    }

    .DateTagBar {
      margin-top: 1.0rem;
    }
  </style>
</head>

<body>
  <nav class="Navbar">
    <a href="/">
      <div class="Navbar__Btn"><span><img class="inline-img-icon" src="https://samillwong.github.io/images/profile.jpg"></span> <span>Home</span></div>
    </a>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  </nav>
  <header class="Header">
      
    <div class="Header__Spacer Header__Spacer--NoCover">
    </div>
    
    <div class="Header__Icon"><span>üîê</span></div>
    
    <h1 class="Header__Title">Vault - IJCTF 2021</h1>
        
    <div class="DateTagBar">
          
      <span class="DateTagBar__Item DateTagBar__Date">Posted on Sun, Jul 25, 2021</span>
          
          
      <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--purple">
          <a href="tag/IJCTF_2021">IJCTF_2021</a>
      </span>
      
      <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--gray">
          <a href="tag/Forensics">Forensics</a>
      </span>
      
      <span class="DateTagBar__Item DateTagBar__Tag DateTagBar__Tag--blue">
          <a href="tag/Network_Analysis">Network_Analysis</a>
      </span>
      
    </div>
    <div class="Article__Desc">
        A forensics category challenge on recovering TLS session keys from a packet capture, and decrypting TLS traffic tunnelled over ICMP (ping) through a SOCKS proxy, then recovering files from partial HTTP/2 requests.
    </div>
        
  </header>
      <article id="https://www.notion.so/6954c33c138d4c91bc4f8bf352488e65" class="PageRoot PageRoot--FullWidth"><h2 id="https://www.notion.so/440e96b7931d4809a73c547e00d8ef71" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/440e96b7931d4809a73c547e00d8ef71"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Challenge description</span></span></h2><div id="https://www.notion.so/2113606da4a943459896313eaf35ae19" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">A robber broke into our vault in the middle of night. There&#x27;s an indication that the robber tried to steal some items which are considered as confidential assets. Could you figure it out?</span></span></p></div><div id="https://www.notion.so/525fff6ad9304a69a940d23a63cb9c6e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Flag format: </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">IJCTF{[a-f0-9]{32}}</code></span></span></p></div><div id="https://www.notion.so/f02f7dad8465429fb4bf39d48d529d7f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Author: </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Avilia#1337</code></span></span></p></div><div id="https://www.notion.so/fb24b23e4f8f4d539a3d32124d1920cb" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Hint #1: &quot;When the incident happened, the attacker got into our </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">IP over ICMP</code></span><span class="SemanticString"> tunnel network to access an </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HTTP/2</code></span><span class="SemanticString"> web-server with </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">SSL</code></span><span class="SemanticString"> enabled.&quot;</span></span></p></div><div id="https://www.notion.so/3903fa4f8e1b4b28887a55ea6eed1abf" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Hint #2: &quot;Even so, our captured logs aren&#x27;t precise enough. Each packet has an unusual timestamp and it&#x27;s kinda messy...&quot;</span></span></p></div><a id="https://www.notion.so/444e91400c824128864a576b5b6ff402" class="File" href="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F9c9460e7-a032-4f51-856d-f6ced1df9184%2Flog.tar.xz?table=block&amp;id=444e9140-0c82-4128-864a-576b5b6ff402"><div><div class="File__Icon"><svg viewBox="0 0 30 30" style="width:1.35em;height:1.35em;fill:inherit"><g><path d="M22,8v12c0,3.866-3.134,7-7,7s-7-3.134-7-7V8c0-2.762,2.238-5,5-5s5,2.238,5,5v12c0,1.657-1.343,3-3,3s-3-1.343-3-3V8h-2v12c0,2.762,2.238,5,5,5s5-2.238,5-5V8c0-3.866-3.134-7-7-7S6,4.134,6,8v12c0,4.971,4.029,9,9,9s9-4.029,9-9V8H22z"></path></g></svg></div><div><span class="File__Title">log.tar.xz</span><span class="File__Size">495.7KB</span></div></div></a><h2 id="https://www.notion.so/fc4eec9ac38b471cbec67a3201f51fb9" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/fc4eec9ac38b471cbec67a3201f51fb9"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Investigating the packet capture</span></span></h2><div id="https://www.notion.so/6771798975004c359bbf8695687e601b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">We are provided with a </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">log.tar.xz</code></span><span class="SemanticString"> archive from the challenge description, which we can decompress using </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">xz</code></span><span class="SemanticString"> and </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">tar</code></span><span class="SemanticString"> as so:</span></span></p></div><div id="https://www.notion.so/399a9127f23d4e14b4b77bef6b598e1b" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">$ xz -d log.tar.xz</code></span></span></p></div><div id="https://www.notion.so/bf2c2b85cb304f159fa7a85f99c46275" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">$ tar -xvf log.tar</code></span></span></p></div><div id="https://www.notion.so/29eccd7e3e5442f699d78bf6559d020d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">This should produce a </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">log.pcap</code></span><span class="SemanticString"> file.</span></span></p></div><div id="https://www.notion.so/2a98dc48768f413ea19a9675db1f6aa3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Running </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">strings</code></span><span class="SemanticString"> against the </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">.pcap</code></span><span class="SemanticString"> file, we pipe the output to </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">sort</code></span><span class="SemanticString"> and </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">uniq</code></span><span class="SemanticString"> to only display unique entries, then </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">grep ......</code></span><span class="SemanticString"> to display only lines with length greater or equal to 6:</span></span></p></div><div id="https://www.notion.so/e9dec5c404444751b4a4ce0aad7febc8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">$ strings log.pcap | sort | uniq | grep ......</code></span></span></p></div><pre id="https://www.notion.so/4205c673ddfa4c03a4e9a2690616adb6" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span>...
CLIENT_RANDOM
Compressed: 202
Extracting archive: flag.zip
p7zip Version 16.02 (locale=C.UTF-8,Utf16=on,HugeFiles=on,32 bits,1 CPU LE)
&amp;p/home/pi/projects/ctf
python3 download.py flag.zip
python3 download.py pass.txt
uid=1000(pi) gid=1000(pi) groups=1000(pi),4(adm),20(dialout),24(cdrom),27(sudo),29(audio),44(video),46(plugdev),60(games),100(users),105(input),109(netdev),114(docker),116(lpadmin),997(gpio),998(i2c),999(spi)
whoami
xargs -n1 -a sslkeylogfile</span></span></span></code></pre><div id="https://www.notion.so/292ab2900e124761881d093a1819662c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">We see mentions of files </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">flag.zip</code></span><span class="SemanticString">, </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">pass.txt</code></span><span class="SemanticString">, </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">download.py</code></span><span class="SemanticString">, and </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">sslkeylogfile</code></span><span class="SemanticString">, as well as commands such as </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">id</code></span><span class="SemanticString">, </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">python3</code></span><span class="SemanticString"> and </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">xargs</code></span><span class="SemanticString"> being run.</span></span></p></div><div id="https://www.notion.so/b54e5b13166541bf9499423b8407d2cb" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Opening the packet capture file </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">log.pcap</code></span><span class="SemanticString"> in Wireshark, we see a conversation between </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">192.168.1.30</code></span><span class="SemanticString"> and </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">192.168.1.205</code></span><span class="SemanticString"> through ICMP (ping), along with some fragmented IPv4 packets.</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/cf7ac19bd4bd4fad84516cc6070a10ac" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">From the first hint, we know that the attacker used an IP over ICMP tunnel network to access an HTTP/2 web server with SSL.</span></span></li><li id="https://www.notion.so/d1521fa4c1e04b92993fbd1abef2d1dd" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">From the second hint, we also know that the capture logs were imprecise and the packet timestamps were unusual.</span></span></li></ol><div id="https://www.notion.so/209476285e034d68ae82518e49ed37b9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Looking at Wireshark, we notice some of the packets have negative time values. This should not be possible, packets cannot travel back in time before the capture started. Also, the frame numbers are all over the place and are not ordered correctly.</span></span></p></div><div id="https://www.notion.so/40a5a19156b14197816a5c18c5814840" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">We can fix the packet ordering issue using the </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">reordercap</code></span><span class="SemanticString"> tool, which should come installed with Wireshark:</span></span></p></div><div id="https://www.notion.so/d16fddfa6c8b4db1a833f68c920c82af" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">$ reordercap log.pcap log_ordered.pcap</code></span></span></p></div><div id="https://www.notion.so/6c4e83745a4744a5bba5acff50577c97" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">If the reordering was successful, there should be 167 fragmented IPv4 packets with size of 1514 bytes in the newly created </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">log_ordered.pcap</code></span><span class="SemanticString"> file. With the ordering fixed, we can then start analysing the individual packets.</span></span></p></div><h2 id="https://www.notion.so/26304cbdab8d49f180ad854c5df9c677" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/26304cbdab8d49f180ad854c5df9c677"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Splicing the packet headers</span></span></h2><div id="https://www.notion.so/3f6d0e72704d4e09811ffc1ca4abcf82" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Looking at one of the fragmented IPv4 packets, we see that there is a data segment with 1480 bytes of data:</span></span></p></div><div id="https://www.notion.so/b964787f55894c509e716554841a6476" class="Image Image--Normal"><figure><a href="https://i.imgur.com/tYUEddZ.png?width=1392"><img src="https://i.imgur.com/tYUEddZ.png?width=1392" style="width:1392px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/1600d6116ef24a23b0ae71bfcc9f2a4d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">At first, the data may look like random bytes. But, if we look carefully, we can see there is a malformed Ethernet header, followed by an IP header, and then a TCP header:</span></span></p></div><div id="https://www.notion.so/3f832a5eddae489587a0cb72f6c21bde" class="Image Image--Normal"><figure><a href="https://i.imgur.com/5FixP4u.png?width=1392"><img src="https://i.imgur.com/5FixP4u.png?width=1392" style="width:1392px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/5c7c3e6e27a64c0c8115493f4663049d" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Searching for the bytes in the malformed Ethernet header </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">00 00 4a e3 f9 24 34 44 68 61 6e 73 07</code></span><span class="SemanticString">, we were able to determine the specific application used to establish the ICMP tunnel, called &quot;Hans&quot; (</span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://github.com/friedrich/hans/blob/master/src/worker.h">https://github.com/friedrich/hans</a></span><span class="SemanticString">). This header is inserted by the Hans application. We can also see the </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">0x07</code></span><span class="SemanticString"> byte at the end, which is defined as </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">TYPE_DATA</code></span><span class="SemanticString"> in the source code under </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">src/worker.h</code></span><span class="SemanticString">:</span></span></p></div><pre id="https://www.notion.so/1ae6dc51b08d4550a942068909dc6da1" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span><span class="token keyword">enum</span> <span class="token class-name">Type</span>
<span class="token punctuation">{</span>
    TYPE_RESET_CONNECTION <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
    TYPE_CONNECTION_REQUEST <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>
    TYPE_CHALLENGE <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>
    TYPE_CHALLENGE_RESPONSE <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span>
    TYPE_CONNECTION_ACCEPT <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span>
    TYPE_CHALLENGE_ERROR <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">,</span>
    TYPE_DATA <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">,</span>
    TYPE_POLL <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">,</span>
    TYPE_SERVER_FULL <span class="token operator">=</span> <span class="token number">9</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></span></span></span></code></pre><div id="https://www.notion.so/8750153a9e264a299d99dbf61461a3b1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">We know the TCP data inside of the ICMP data has to contain the TLS traffic which the attacker used to exfiltrate data, or the handshakes associated with them. If we can somehow restore the original TLS packets, then there is a possibility where we can extract the session keys and use them to decrypt the rest of the packets.</span></span></p></div><div id="https://www.notion.so/faa6550d1b5246e6b73f85a5d55cc53e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">This can be achieved by transplanting the Ethernet header from the ICMP packet to the ICMP data segment, and removing the magic/type header inserted by Hans. In fact, we can simplify it to only one cut operation by removing the TCP header and the Hans header altogether.</span></span></p></div><div id="https://www.notion.so/b0978335537b4377b1d6970bda572ec7" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Using the </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">editcap</code></span><span class="SemanticString"> tool and following the documentation </span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://www.wireshark.org/docs/man-pages/editcap.html">here</a></span><span class="SemanticString">, we cut away 33 bytes (20 bytes from TCP header of ICMP + 13 bytes from Hans) starting from offset byte 15 (after 14 bytes from Ethernet header of ICMP) for each packet, then export the packets into a </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">log_chopped.pcap</code></span><span class="SemanticString"> file:</span></span></p></div><div id="https://www.notion.so/f521a536252d48cd850ca5b56e5c6896" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">$ editcap -C 15:33 log_ordered.pcap log_chopped.pcap</code></span></span></p></div><div id="https://www.notion.so/dfb3db5be10d421da3d55d8b68dc9453" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Opening </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">log_chopped.pcap</code></span><span class="SemanticString"> file in Wireshark, we see the ICMP packets have now changed into either TCP or Socks packets, the source/destination address and ports have also changed. This is likely because the attacker used a Socks proxy when attacking our victim. To combat this and allow Wireshark to read the traffic properly as TLS, we can add an entry to the &quot;Decode As&quot; list under the &quot;Analyze&quot; tab, pointing port 1080 to TLS:</span></span></p></div><div id="https://www.notion.so/b99f8a4799a849a7a9ef2e9c2ea76dc7" class="Image Image--Normal"><figure><a href="https://i.imgur.com/XYZz0Xq.png?width=624"><img src="https://i.imgur.com/XYZz0Xq.png?width=624" style="width:624px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/49e573a91b4743f5ba92516318e022a8" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">This basically tells Wireshark to treat all traffic on TCP port 1080 as TLS, and not as Socks.</span></span></p></div><h2 id="https://www.notion.so/658aef0e6ffc4df6b225e6b6dae96b50" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/658aef0e6ffc4df6b225e6b6dae96b50"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Extracting the TLS session keys</span></span></h2><div id="https://www.notion.so/f02492982da24444a98460a44f6d4b61" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Earlier, when we did </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">strings</code></span><span class="SemanticString"> on the </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">log.pcap</code></span><span class="SemanticString"> file, we noticed that the attacker ran </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">xargs -n1 -a sslkeylogfile</code></span><span class="SemanticString"> on the victim&#x27;s system, which would effectively print the contents of </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">sslkeylogfile</code></span><span class="SemanticString"> to the output stream. We should be able to follow this output as it is not protected by TLS, and recover the TLS session keys.</span></span></p></div><div id="https://www.notion.so/15808bab37544c2f91e18102c59403c9" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">From the </span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format">Mozilla NSS key log documentations</a></span><span class="SemanticString">, we know the </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">sslkeylogfile</code></span><span class="SemanticString"> follows a format of </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">&lt;Label&gt; &lt;space&gt; &lt;ClientRandom&gt; &lt;space&gt; &lt;Secret&gt;</code></span><span class="SemanticString">. </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ClientRandom</code></span><span class="SemanticString"> is encoded as 64 hexadecimal characters, and </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Secret</code></span><span class="SemanticString"> is encoded as 96 hexadecimal characters (for TLS 1.0-2). For example, a key may look like this:</span></span></p></div><pre id="https://www.notion.so/06d97de3fd68451dbf6736ecafa8c183" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span>CLIENT_RANDOM cf6b8752f4b47c9c28b07ba7da366f98afcc335931f08df83c30ebe2c7bcce32 a832cf19fa6b414fce74fa796b39d898c0825991547eebd20abe951ad2c586490d2703e4f596de3b6b4be417a2caa250</span></span></span></code></pre><div id="https://www.notion.so/dbeac00918bb400facb8fa08e362aab0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">In </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">log_chopped.pcap</code></span><span class="SemanticString">, we use Wireshark&#x27;s search feature to look for the string </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">CLIENT_RANDOM</code></span><span class="SemanticString"> in the packet bytes. Select any packet from the search result and follow the TCP stream by right-clicking on it then clicking </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Follow -&gt; TCP Stream</code></span><span class="SemanticString">. This should open a new window showing the entire stream as ASCII:</span></span></p></div><div id="https://www.notion.so/db52fdd5c6af41e9b8c8902bd655c4a6" class="Image Image--Normal"><figure><a href="https://i.imgur.com/txTocC4.png?width=1200"><img src="https://i.imgur.com/txTocC4.png?width=1200" style="width:1200px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/08e1247b8c824b7088787bc5be433175" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">From here, it is trivial to extract the contents of </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">sslkeylogfile</code></span><span class="SemanticString">. We can simply copy all lines containing the session keys starting from </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">CLIENT_RANDOM</code></span><span class="SemanticString"> and paste them into a file named </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">sslkeylogfile.txt</code></span><span class="SemanticString">.</span></span></p></div><div id="https://www.notion.so/79cfd277bf25482491fe5ec5fc1d2af1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Though, we&#x27;re not done quite yet. Since the attacker used </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">xargs -n1</code></span><span class="SemanticString"> to display each argument into separate lines, the format of our keys is going to be incorrect. We need to replace the line characters </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">\n</code></span><span class="SemanticString"> between </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">ClientRandom</code></span><span class="SemanticString"> and </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Secret</code></span><span class="SemanticString"> into space characters, and this can be done using </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">paste</code></span><span class="SemanticString"> as so:</span></span></p></div><div id="https://www.notion.so/155bd427077a4842ac14e6444df9e38a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">$ paste -d&quot; &quot; - - - &lt; sslkeylogfile.txt &gt; sslkeylogfile</code></span></span></p></div><div id="https://www.notion.so/1a1144e452134da4a030768fb4362592" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">The </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">sslkeylogfile</code></span><span class="SemanticString"> should now contain 166 keys, as seen here:</span></span></p></div><div id="https://www.notion.so/8662d652dc9d4f8b93c0c286b01a2708" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">$ wc sslkeylogfile &amp;&amp; md5sum sslkeylogfile</code></span></span></p></div><pre id="https://www.notion.so/e015b764898f41e195362331abf367b0" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span>166   498 29216 sslkeylogfile
9776acd3c0499be64e9653cb27f30720  sslkeylogfile</span></span></span></code></pre><div id="https://www.notion.so/a47c1767cac04d2e9303f000a0ad6096" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">With the session keys extracted, we can then decrypt the packets.</span></span></p></div><h2 id="https://www.notion.so/e6f146844b05409f8d013b9228b2493a" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/e6f146844b05409f8d013b9228b2493a"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Injecting secrets and decrypting TLS traffic</span></span></h2><div id="https://www.notion.so/bc2d104d399a4d099f5b5b038eeb4119" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">There are two ways we can approach the decryption:</span></span></p></div><ol class="NumberedListWrapper"><li id="https://www.notion.so/5d98966034994e19a76030cdd0432bbe" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">Use Wireshark&#x27;s built-in support for master secret log files for TLS under </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Preferences -&gt; Protocol -&gt; TLS -&gt; (Pre)-Master-Secret log filename</code></span><span class="SemanticString">, select the </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">sslkeylogfile</code></span><span class="SemanticString"> we just extracted, and the packets will be automatically decrypted by Wireshark in the GUI.</span></span></li><li id="https://www.notion.so/786f3d93b2f64c46b366c132978b5215" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">Use </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">editcap</code></span><span class="SemanticString"> to inject the secret to the </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">.pcap</code></span><span class="SemanticString"> file, as so:</span></span><div id="https://www.notion.so/e26d6829769d49eb9be63f47fbaafaf0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">$ editcap --inject-secrets tls,sslkeylogfile log_chopped.pcap log_decrypted.pcap</code></span></span></p></div></li></ol><div id="https://www.notion.so/51e4aefb4d9945f9b4ba04ca7f8baf64" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Either methods will allow us to read the contents of the packets, but the </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">editcap</code></span><span class="SemanticString"> approach will allow us to use command-line tools later to recover the files more easily. If you want to hand transcribe hexadecimals later on, then choose method 1. ;)</span></span></p></div><h2 id="https://www.notion.so/0ca3487201c245c2a222e88d4a8ebf61" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/0ca3487201c245c2a222e88d4a8ebf61"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Recovering flag.zip and pass.txt</span></span></h2><div id="https://www.notion.so/9f701076aaef4b3ba48419dbbdcfde8a" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Looking at the HTTP/2 packets in </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">log_decrypted.pcap</code></span><span class="SemanticString"> with filter </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">http2</code></span><span class="SemanticString">, we see there are GET requests to </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">/files/flag.zip</code></span><span class="SemanticString"> and </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">/files/pass.txt</code></span><span class="SemanticString">:</span></span></p></div><div id="https://www.notion.so/23195342423545548a58c7e3e9fb99a2" class="Image Image--PageWidth"><figure><a href="https://i.imgur.com/N9bZFyg.png"><img src="https://i.imgur.com/N9bZFyg.png" style="width:100%"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/caeb9090a6944a149fd3e6315a2d00cd" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Alongside the </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">HEADERS</code></span><span class="SemanticString"> and </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Magic</code></span><span class="SemanticString"> packets, we also see many </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">DATA</code></span><span class="SemanticString"> packets. Inspecting them further with Wireshark, we see that each of the </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">DATA</code></span><span class="SemanticString"> packet has a status of </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">206 Partial Content</code></span><span class="SemanticString">, they each carry either 1 or 2 bytes of data depending on if the </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Content-Type</code></span><span class="SemanticString"> header is </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">text/plain</code></span><span class="SemanticString"> or </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">application/zip</code></span><span class="SemanticString">, and nearly all of them have an unusual header </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Content-Range</code></span><span class="SemanticString">.</span></span></p></div><div id="https://www.notion.so/52cab22d15ec40e39415dccacea9b3e2" class="Image Image--Normal"><figure><a href="https://i.imgur.com/YmYfG18.png?width=720"><img src="https://i.imgur.com/YmYfG18.png?width=720" style="width:720px"/></a><figcaption><span class="SemanticStringArray"></span></figcaption></figure></div><div id="https://www.notion.so/38b9fb3251474f44bc756f801c312682" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">In essence, what&#x27;s happening here - is that the attacker is gradually sending either 1 or 2 bytes of data through HTTP/2. The bytes are ordered by the </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Content-Range</code></span><span class="SemanticString"> header. For example, </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">bytes 22-23/202</code></span><span class="SemanticString"> would mean the data in the packet belongs in byte locations 22 to 23, out of 202 bytes. This implies, in order for us to recover the two files, we need to piece together the individual bytes of data from all of the </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">DATA</code></span><span class="SemanticString"> packets according to the </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">Content-Range</code></span><span class="SemanticString"> header.</span></span></p></div><div id="https://www.notion.so/0e4fec4d702440a5baa41c8d738af93e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">It is possible to recover the files by hand transcribing the hexadecimals from all 166 packets (if you&#x27;re up for the task). Fortunately, there is a tool that can help us with this. We can use </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">tshark</code></span><span class="SemanticString">, which is a packet analysis tool much like Wireshark, but it is capable of quickly exporting the packets&#x27; range and data as columns in the command-line, allowing us to easily recover the bytes.</span></span></p></div><div id="https://www.notion.so/d7f37200938040e89217a36988f2d94f" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">$ tshark -r log_decrypted.pcap -Y &quot;http2&quot; -T fields -e http2.headers.range -e http2.data.data | xargs -n2 &gt; bytes.txt</code></span></span></p></div><div id="https://www.notion.so/46a6e42c641c4d0a96312485fae6723c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Here, we first take </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">log_decrypted.pcap</code></span><span class="SemanticString"> as the input file (</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">-r</code></span><span class="SemanticString">), using </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">http2</code></span><span class="SemanticString"> as the display filter (</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">-Y</code></span><span class="SemanticString">), and printing the fields (</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">-T</code></span><span class="SemanticString">) of </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">http2.headers.range</code></span><span class="SemanticString"> and </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">http2.data.data</code></span><span class="SemanticString"> (</span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">-e</code></span><span class="SemanticString">). We also pipe the output to </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">xargs -n2</code></span><span class="SemanticString"> to make each packet display neatly on one line instead of two, and finally output it to a </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">bytes.txt</code></span><span class="SemanticString"> file. The file should look something like this:</span></span></p></div><pre id="https://www.notion.so/b4725a24aa504f5b97d8397f51cd8f77" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span>bytes=53-53 31
bytes=34-34 32
bytes=27-27 39
bytes=52-52 36
bytes=55-55 66
...</span></span></span></code></pre><div id="https://www.notion.so/81a87efbec034258b11bee10664646c1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">We have the hexadecimal bytes of </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">flag.zip</code></span><span class="SemanticString"> and </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">pass.txt</code></span><span class="SemanticString">, but the bytes are mixed together in one file and we want to separate them. To do this, we can pass it through a few more filters:</span></span></p></div><div id="https://www.notion.so/c42e8f660cd54932a1f04134057a41a0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">$ cat bytes.txt | awk &#x27;length($2)==2 {print $0}&#x27; | cut -d&quot;=&quot; -f2 | sort -n</code></span></span></p></div><div id="https://www.notion.so/8db4685d0f574434bc8603a53ebcbff3" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">This reads the contents of </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">bytes.txt</code></span><span class="SemanticString">, and prints the line if the byte column has a length of 2. Then removes the &quot;bytes=&quot; string before the range, and sorts the values numerically. The result should be the hexadecimal bytes of </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">pass.txt</code></span><span class="SemanticString"> in order of the range, and will look something like this:</span></span></p></div><pre id="https://www.notion.so/c6aaab64f1254a90aee33ba94047fe1a" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span>0-0 30
1-1 65
2-2 64
3-3 62
4-4 63
...</span></span></span></code></pre><div id="https://www.notion.so/6ea4216997e44b318c820c5019d05254" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">We can verify that no bytes are missing from the output, and that all bytes are in the correct order.</span></span></p></div><div id="https://www.notion.so/ee0e2e2999ad4cc9baaa87f1732e662c" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Now, we just have to remove the range column and we will get the password&#x27;s hex:</span></span></p></div><div id="https://www.notion.so/a0b7ae5a31d34aef8c9419273db93429" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">$ cat bytes.txt | awk &#x27;length($2)==2 {print $0}&#x27; | cut -d&quot;=&quot; -f2 | sort -n | cut -d&quot; &quot; -f2 &gt; pass.hex</code></span></span></p></div><div id="https://www.notion.so/7b2d6fc35c9c4317b27fdebb5bec2ec1" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">To convert it from hexadecimal to bytes, we can use </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">xxd</code></span><span class="SemanticString">:</span></span></p></div><div id="https://www.notion.so/a2d66aa88f7d45e185efe49870b5f795" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">$ xxd -r -p pass.hex &gt; pass.txt</code></span></span></p></div><div id="https://www.notion.so/86b41f88785e49a59e73decfe8c4cc07" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Now repeat the process for </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">flag.zip</code></span><span class="SemanticString">, but this time using </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">length($2)==4</code></span><span class="SemanticString"> instead. We can also skip the intermediate hex file as so:</span></span></p></div><div id="https://www.notion.so/022b01e501a94283a07a0dd457d74be0" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">$ cat bytes.txt | awk &#x27;length($2)==4 {print $0}&#x27; | cut -d&quot;=&quot; -f2 | sort -n | cut -d&quot; &quot; -f2 | xxd -r -p &gt; flag.zip</code></span></span></p></div><h2 id="https://www.notion.so/6503ea9ca6ca40d6988ca2148947f5b8" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/6503ea9ca6ca40d6988ca2148947f5b8"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Getting the flag</span></span></h2><div id="https://www.notion.so/6d994e0de4c74b7bbf9a124d6556ed0e" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString">Now all that&#x27;s left to do is decompress </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">flag.zip</code></span><span class="SemanticString"> using </span><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">pass.txt</code></span><span class="SemanticString"> and get the flag!</span></span></p></div><div id="https://www.notion.so/78fc48b52eda4f0fa17b508e6bd73271" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">$ unzip flag.zip</code></span></span></p></div><pre id="https://www.notion.so/773e4ae501cc4e4ab1e1afe65fdda63f" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span>Archive:  flag.zip
[flag.zip] flag.txt password: 0edbca2531daefac9c5c84c016792713fd23681ea8bc1b3d088b617f75940313
 extracting: flag.txt</span></span></span></code></pre><div id="https://www.notion.so/5b6e6861e90842bd8c3c569e65252514" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"><span class="SemanticString"><code class="SemanticString__Fragment SemanticString__Fragment--Code">$ cat flag.txt</code></span></span></p></div><pre id="https://www.notion.so/2d407e7f0316488a9370e11a3262af4e" class="Code Code--NoWrap"><code><span class="SemanticStringArray"><span class="SemanticString"><span>IJCTF{aa51f2cc8eaf466a277da70db3a3c576}</span></span></span></code></pre><h2 id="https://www.notion.so/8ac76fc4a73448abb4be937d6abd3d9f" class="ColorfulBlock ColorfulBlock--ColorDefault Heading Heading--2"><a class="Anchor" href="#https://www.notion.so/8ac76fc4a73448abb4be937d6abd3d9f"><svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><span class="SemanticStringArray"><span class="SemanticString">Resources</span></span></h2><ol class="NumberedListWrapper"><li id="https://www.notion.so/d1ca1d6fe0554a14a3928a9755b8f548" class="NumberedList" value="1"><span class="SemanticStringArray"><span class="SemanticString">friedrich/hans: IP over ICMP - </span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://github.com/friedrich/hans">https://github.com/friedrich/hans</a></span></span></li><li id="https://www.notion.so/722136544fd54a19b7665073020e302f" class="NumberedList" value="2"><span class="SemanticStringArray"><span class="SemanticString">editcap - The Wireshark Network Analyzer 3.4.7 - </span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://www.wireshark.org/docs/man-pages/editcap.html">https://www.wireshark.org/docs/man-pages/editcap.html</a></span></span></li><li id="https://www.notion.so/f63c41f453a949e4ac03dbc26409cb6e" class="NumberedList" value="3"><span class="SemanticStringArray"><span class="SemanticString">NSS Key Log Format - Mozilla | MDN - </span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format">https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format</a></span></span></li><li id="https://www.notion.so/46c6627857444888a8168bb1232b1507" class="NumberedList" value="4"><span class="SemanticStringArray"><span class="SemanticString">Wireshark Tutorial: Decrypting HTTPS Traffic - </span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://unit42.paloaltonetworks.com/wireshark-tutorial-decrypting-https-traffic/">https://unit42.paloaltonetworks.com/wireshark-tutorial-decrypting-https-traffic/</a></span></span></li><li id="https://www.notion.so/cca76af11dd64f92bf6b4e7537c5db25" class="NumberedList" value="5"><span class="SemanticStringArray"><span class="SemanticString">Decrypting TLS Streams With Wireshark: Part 1 - </span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://blog.didierstevens.com/2020/12/14/decrypting-tls-streams-with-wireshark-part-1/">https://blog.didierstevens.com/2020/12/14/decrypting-tls-streams-with-wireshark-part-1/</a></span></span></li><li id="https://www.notion.so/d7d225b3e19e466f9c1ba97b6dccb1c5" class="NumberedList" value="6"><span class="SemanticStringArray"><span class="SemanticString">tshark - The Wireshark Network Analyzer 3.4.7 - </span><span class="SemanticString"><a class="SemanticString__Fragment SemanticString__Fragment--Link" href="https://www.wireshark.org/docs/man-pages/tshark.html">https://www.wireshark.org/docs/man-pages/tshark.html</a></span></span></li></ol><div id="https://www.notion.so/0d8131280ce24df6aa15795ddfd5bace" class="ColorfulBlock ColorfulBlock--ColorDefault Text"><p class="Text__Content"><span class="SemanticStringArray"></span></p></div></article>
  <footer class="Footer">
        <div>&copy; samiko@127.0.0.1~$ &centerdot; 2021</div>
        <div>&centerdot;</div>
        <div>Powered by <a href="https://github.com/dragonman225/notablog" target="_blank"
            rel="noopener noreferrer">Notablog</a>.
        </div>
    </footer>
</body>

</html>
